#include <iostream>
#include <cstdlib>
#include <vector>
#include <fstream>
#include <string>
#include <iomanip> // For padding hex with leading 0


using namespace std;

unsigned int lfsr[16] = {0};

// The Rijndael S-box Sr
int sr[256] =  
	{0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
	,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
	,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
	,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
	,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
	,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
	,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
	,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
	,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
	,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
	,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
	,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
	,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
	,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
	,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
	,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};

// The S-Box Sq
unsigned int sq[256] = 
	{0x25, 0x24, 0x73, 0x67, 0xD7, 0xAE, 0x5C, 0x30, 0xA4, 0xEE, 0x6E, 0xCB, 0x7D, 0xB5, 0x82, 0xDB,
	0xE4, 0x8E, 0x48, 0x49, 0x4F, 0x5D, 0x6A, 0x78, 0x70, 0x88, 0xE8, 0x5F, 0x5E, 0x84, 0x65, 0xE2,
	0xD8, 0xE9, 0xCC, 0xED, 0x40, 0x2F, 0x11, 0x28, 0x57, 0xD2, 0xAC, 0xE3, 0x4A, 0x15, 0x1B, 0xB9,
	0xB2, 0x80, 0x85, 0xA6, 0x2E, 0x02, 0x47, 0x29, 0x07, 0x4B, 0x0E, 0xC1, 0x51, 0xAA, 0x89, 0xD4,
	0xCA, 0x01, 0x46, 0xB3, 0xEF, 0xDD, 0x44, 0x7B, 0xC2, 0x7F, 0xBE, 0xC3, 0x9F, 0x20, 0x4C, 0x64,
	0x83, 0xA2, 0x68, 0x42, 0x13, 0xB4, 0x41, 0xCD, 0xBA, 0xC6, 0xBB, 0x6D, 0x4D, 0x71, 0x21, 0xF4,
	0x8D, 0xB0, 0xE5, 0x93, 0xFE, 0x8F, 0xE6, 0xCF, 0x43, 0x45, 0x31, 0x22, 0x37, 0x36, 0x96, 0xFA,
	0xBC, 0x0F, 0x08, 0x52, 0x1D, 0x55, 0x1A, 0xC5, 0x4E, 0x23, 0x69, 0x7A, 0x92, 0xFF, 0x5B, 0x5A,
	0xEB, 0x9A, 0x1C, 0xA9, 0xD1, 0x7E, 0x0D, 0xFC, 0x50, 0x8A, 0xB6, 0x62, 0xF5, 0x0A, 0xF8, 0xDC,
	0x03, 0x3C, 0x0C, 0x39, 0xF1, 0xB8, 0xF3, 0x3D, 0xF2, 0xD5, 0x97, 0x66, 0x81, 0x32, 0xA0, 0x00,
	0x06, 0xCE, 0xF6, 0xEA, 0xB7, 0x17, 0xF7, 0x8C, 0x79, 0xD6, 0xA7, 0xBF, 0x8B, 0x3F, 0x1F, 0x53,
	0x63, 0x75, 0x35, 0x2C, 0x60, 0xFD, 0x27, 0xD3, 0x94, 0xA5, 0x7C, 0xA1, 0x05, 0x58, 0x2D, 0xBD,
	0xD9, 0xC7, 0xAF, 0x6B, 0x54, 0x0B, 0xE0, 0x38, 0x04, 0xC8, 0x9D, 0xE7, 0x14, 0xB1, 0x87, 0x9C,
	0xDF, 0x6F, 0xF9, 0xDA, 0x2A, 0xC4, 0x59, 0x16, 0x74, 0x91, 0xAB, 0x26, 0x61, 0x76, 0x34, 0x2B,
	0xAD, 0x99, 0xFB, 0x72, 0xEC, 0x33, 0x12, 0xDE, 0x98, 0x3B, 0xC0, 0x9B, 0x3E, 0x18, 0x10, 0x3A,
	0x56, 0xE1, 0x77, 0xC9, 0x1E, 0x9E, 0x95, 0xA3, 0x90, 0x19, 0xA8, 0x6C, 0x09, 0xD0, 0xF0, 0x86};

unsigned int r1 = 0;
unsigned int r2 = 0;
unsigned int r3 = 0;

/**
 *	MULx maps 16 bits to 8 bits
 *
 *	@param v - First 8 bit input
 *	@param c - Second 8 bit input
 *	@return 8 bits
 */
unsigned int mulX(unsigned int v, unsigned int c){
	int leftmost = (v & 0xFF) >> 7;
	return leftmost == 1 ? (((v << 1)&0xFF) ^ c) : ((v << 1)&0xFF);
}

/**
 *	MULx maps 16 bits and a positive integer i to 8 bits
 *
 *	@param v - First 8 bit input
 *	@param i - a positive integer
 *	@param c - Second 8 bit input
 *	@return 8 bits
 */
unsigned int mulY(unsigned int v, int i, unsigned int c){
	if(i < 0){
		cerr << "invalid input i: " << i << " to mulY";
		exit(1);
	}
	return i == 0 ? v&0xFF : (mulX(mulY(v, i-1, c),c)&0xFF);
}

/**
 *	The S-Box S1. Maps a 32 bit input to a 32 bit output
 *
 *	@param w - A 32 bit word
 *	@return A 32 bit output
 */
unsigned int s1(unsigned int w){
 
	unsigned int w0 = (w >> 24) & 0xFF;
	unsigned int w1 = (w >> 16) & 0xFF;
	unsigned int w2 = (w >> 8) & 0xFF;
	unsigned int w3 =  (w & 0xFF);

	unsigned int r0 = (mulX(sr[w0], 0x1B) ^ sr[w1] ^ sr[w2] ^ (mulX(sr[w3], 0x1B) ^ sr[w3]));
	unsigned int r1 = ((mulX(sr[w0], 0x1B) ^ sr[w0]) ^ mulX(sr[w1], 0x1B) ^ sr[w2] ^ sr[w3]);
	unsigned int r2 = (sr[w0] ^ (mulX(sr[w1], 0x1B) ^ sr[w1]) ^ mulX(sr[w2], 0x1B) ^ sr[w3]);
	unsigned int r3 = (sr[w0] ^ sr[w1] ^ (mulX(sr[w2], 0x1B) ^ sr[w2]) ^ mulX(sr[w3], 0x1B));

	return ((r0 << 24) | (r1 << 16) | (r2 << 8) | r3);
}

/**
 * The S-Box S2. Maps a 32 bit input to a 32 bit output
 *
 *	@param w - A 32 bit word
 *	@return A 32 bit word
 */
unsigned int s2(unsigned int w){

	unsigned int w0 = (w >> 24) & 0xFF;
	unsigned int w1 = (w >> 16) & 0xFF;
	unsigned int w2 = (w >> 8) & 0xFF;
	unsigned int w3 =  (w & 0xFF);

	unsigned int r0 = (mulX(sq[w0], 0x69) ^ sq[w1] ^ sq[w2] ^ (mulX(sq[w3], 0x69) ^ sq[w3]));
	unsigned int r1 = ((mulX(sq[w0], 0x69) ^ sq[w0]) ^ mulX(sq[w1], 0x69) ^ sq[w2] ^ sq[w3]);
	unsigned int r2 = (sq[w0] ^ (mulX(sq[w1], 0x69) ^ sq[w1]) ^ mulX(sq[w2], 0x69) ^ sq[w3]);
	unsigned int r3 = (sq[w0] ^ sq[w1] ^ (mulX(sq[w2], 0x69) ^ sq[w2]) ^ mulX(sq[w3], 0x69));

	return ((r0 << 24) | (r1 << 16) | (r2 << 8) | r3);
}

/**
 *	This function simulates the finite state machine.
 *	It calculates the 32 bit output F and updates the 3 registers r1, r2, and r3
 *
 *	@return 32 bit word
 */
unsigned int fsm(){
	unsigned int F = ((lfsr[15] + r1)&0xFFFFFFFF) ^ r2;
	unsigned int r = (r2 + (r3 ^ lfsr[5]))&0xFFFFFFFF;
	r3 = s2(r2);
	r2 = s1(r1);
	r1 = r;
	
	return F;
}

/**
 *	MUL maps 8 bits to 32 bits
 *
 *	@param c - An 8 bit input
 *	@return 32 bits
 */
unsigned int mul(unsigned int c){
	return ((mulY(c, 23, 0xA9) << 24) | (mulY(c, 245, 0xA9) << 16) | (mulY(c, 48, 0xA9) << 8) | mulY(c, 239, 0xA9) );
}

/**
 *	DIV maps 8 bits to 32 bits
 *
 *	@param c - An 8 bit input
 *	@return 32 bits
 */
unsigned int div(unsigned int c){
	return ((mulY(c, 16, 0xA9) << 24) | (mulY(c, 39, 0xA9) << 16) | (mulY(c, 6, 0xA9) << 8) | mulY(c, 64, 0xA9));
}

/**
 *	Clock the LFSR. Can be clocked in initialization or keystream mode
 *
 *	@param mode - 'i' for initialization, 'k' for keystream
 *	@param F - A 32 bit input (The output of FSM). Only required in initialization mode
 */
void clock_lfsr(char mode, unsigned long F = 0){

	unsigned int s00 = (lfsr[0] >> (8*3)) & 0xFF;
	unsigned int s01 = (lfsr[0] >> (8*2)) & 0xFF;
	unsigned int s02 = (lfsr[0] >> 8) & 0xFF;
	unsigned int s03 =  (lfsr[0] & 0xFF);
	unsigned int s110 = (lfsr[11] >> (8*3)) & 0xFF;
	unsigned int s111 = (lfsr[11] >> (8*2)) & 0xFF;
	unsigned int s112 = (lfsr[11] >> 8) & 0xFF;
	unsigned int s113 =  (lfsr[11] & 0xFF);
	unsigned int v = 0;

	if(mode == 'i'){ 
		// Initialization mode
		v = (((s01 << 24) | (s02 << 16) | (s03 << 8) | 0x00) ^ 
						mul(s00) ^ lfsr[2] ^ ((0x00 << 24) | (s110 << 16) | (s111 << 8) | s112) ^ 
						div(s113) ^ F);

	}else if(mode == 'k'){
		// Keystream mode
		v = (((s01 << 24) | (s02 << 16) | (s03 << 8) | 0x00) ^ 
							mul(s00) ^ lfsr[2] ^ ((0x00 << 24) | (s110 << 16) | (s111 << 8) | s112) ^ 
							div(s113));
	}

	for(int i = 0; i < 15; ++i){
		lfsr[i] = lfsr[i+1];
	}
	lfsr[15] = v;
}

// Main
int main(int argc, char const *argv[]){

	if(argc < 5){
		cerr << "Program usage: " << argv[0] << " <key_file> <iv_file> <n> <output_file>" << endl;
		return 1;
	}

	// Output file
	string out_file = argv[4];
	// N = how many 32 keystream words to generate
	int n = atoi(argv[3]);

	// Read in key
	ifstream key_stream(argv[1]);
	string key = "";
	vector<string> keys;
	while(key_stream >> key)
		keys.push_back(key);

	key_stream.close();

	// Key is split in 4 32 bit parts
	unsigned int k0 = strtoul(keys[0].c_str(), NULL, 16 );
	unsigned int k1 = strtoul(keys[1].c_str(), NULL, 16 );
	unsigned int k2 = strtoul(keys[2].c_str(), NULL, 16 );
	unsigned int k3 = strtoul(keys[3].c_str(), NULL, 16 );

	// Read in IV
	ifstream iv_stream(argv[2]);
	string iv = "";
	vector<string> ivs;
	while(iv_stream >> iv)
		ivs.push_back(iv);

	iv_stream.close();

	// IV is split in 4 32 bit parts
	unsigned int iv0 = strtoul(ivs[0].c_str(), NULL, 16 );
	unsigned int iv1 = strtoul(ivs[1].c_str(), NULL, 16 );
	unsigned int iv2 = strtoul(ivs[2].c_str(), NULL, 16 );
	unsigned int iv3 = strtoul(ivs[3].c_str(), NULL, 16 );

	// Initialize lfsr
	unsigned int one = 0xffffffff;
	lfsr[15] = k3 ^ iv0;
	lfsr[14] = k2;
	lfsr[13] = k1;
	lfsr[12] = k0 ^ iv1;
	lfsr[11] = k3 ^ one;
	lfsr[10] = k2 ^ one ^ iv2;
	lfsr[9] = k1 ^ one ^ iv3;
	lfsr[8] = k0 ^ one;
	lfsr[7] = k3;
	lfsr[6] = k2;
	lfsr[5] = k1;
	lfsr[4] = k0;
	lfsr[3] = k3 ^ one;
	lfsr[2] = k2 ^ one;
	lfsr[1] = k1 ^ one;
	lfsr[0] = k0 ^ one;

	// clock lfsr in initialization mode 
	for(int i = 0; i < 32; ++i){
		clock_lfsr('i', fsm());
	}

	// Generate key stream
	fsm();
	clock_lfsr('k');

	vector<unsigned int> keystream;
	for(int i = 0; i < n; ++i){
		unsigned int f = fsm()^lfsr[0];
		keystream.push_back(f);
		clock_lfsr('k');
	}

	// Write to out file
	ofstream of(out_file);
	for(unsigned int i : keystream)
		of << setfill('0') << setw(8) << hex << i << " ";

	// Output for testing
	// for(unsigned int i : keystream)
	// 	cout << setfill('0') << setw(8) << hex << i << endl;

	return 0;
}
